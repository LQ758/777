# 技术使用详情清单

## 📋 项目各部分具体技术使用说明

### 🌐 前端技术使用详情

#### 1. HTML页面结构 (`templates/index.html`)
- **HTML5语义化标签**：使用现代HTML5标准
- **响应式设计**：`<meta name="viewport" content="width=device-width, initial-scale=1.0">`
- **中文本地化**：`<html lang="zh-CN">`

#### 2. 外部CDN资源引用
```html
<!-- CSS框架 -->
<script src="https://cdn.tailwindcss.com"></script>

<!-- 图标库 -->
<script src="https://code.iconify.design/iconify-icon/1.0.7/iconify-icon.min.js"></script>

<!-- 图表库 -->
<script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>

<!-- HTTP客户端 -->
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

<!-- 自定义API测试脚本 -->
<script src="/static/test_api.js"></script>
```

#### 3. CSS技术使用
- **Flexbox布局**：主要布局方式
- **CSS Grid**：模块区域布局 (`grid-template-columns: 1fr 1.2fr`)
- **CSS变量和动画**：
  ```css
  @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(58, 134, 255, 0.5); }
      70% { box-shadow: 0 0 0 12px rgba(58, 134, 255, 0); }
      100% { box-shadow: 0 0 0 0 rgba(58, 134, 255, 0); }
  }
  ```
- **响应式颜色系统**：统一的色彩变量使用

#### 4. JavaScript功能实现
- **ES6+现代语法**：箭头函数、模板字符串、async/await
- **DOM操作**：原生JavaScript DOM API
- **事件处理**：addEventListener事件绑定
- **异步请求**：Axios库进行API调用
- **音频录制**：Web Audio API (`navigator.mediaDevices.getUserMedia`)
- **文件上传**：FormData API处理多媒体文件

### 🔧 后端技术使用详情

#### 1. Flask Web框架 (`app.py`)

**核心导入**：
```python
from flask import Flask, render_template, request, jsonify, send_from_directory, redirect, url_for
```

**应用实例创建**：
```python
app = Flask(__name__)
```

**路由定义**：
- **GET路由**：`@app.route('/', methods=['GET'])`
- **POST路由**：`@app.route('/api/score-pronunciation', methods=['POST'])`
- **多方法路由**：支持GET和POST的API端点

#### 2. 数据库技术栈

**SQLAlchemy ORM**：
```python
from src.core.database import init_database, create_tables
init_database(app)
```

**MySQL连接**：
- 使用SQLAlchemy作为ORM层
- 支持连接池和事务管理
- 配置文件驱动的数据库连接

#### 3. Python包导入和依赖管理

**系统模块**：
```python
import sys
import os
import uuid
import traceback
```

**科学计算**：
```python
import numpy as np
```

**音频处理依赖**：
```python
import librosa          # 音频分析
import soundfile        # 音频文件I/O
import sounddevice      # 录音设备访问
```

**路径管理**：
```python
# 动态路径添加
src_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'src')
sys.path.append(src_dir)
```

### 🤖 AI模型技术使用

#### 1. 发音评分模块 (`src/core/发音评分模块.py`)

**PyTorch深度学习框架**：
```python
import torch
from transformers import Wav2Vec2Processor, Wav2Vec2ForCTC
```

**模型加载和使用**：
```python
# 设备选择（GPU/CPU）
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# 模型实例化
processor = Wav2Vec2Processor.from_pretrained(model_name)
model = Wav2Vec2ForCTC.from_pretrained(model_name)
model = model.to(device)
model.eval()
```

**音频预处理**：
```python
# 音频数据类型转换
if audio_data.dtype != np.float32:
    audio_data = audio_data.astype(np.float32)

# 音频归一化
if np.max(np.abs(audio_data)) > 0:
    audio_data = audio_data / np.max(np.abs(audio_data))
```

**模型推理**：
```python
# 数据预处理
inputs = processor(audio_data, sampling_rate=16000, return_tensors="pt", padding=True)
inputs = {k: v.to(device) for k, v in dict(inputs).items()}

# 模型推理
with torch.no_grad():
    logits = model(**inputs).logits
predicted_ids = torch.argmax(logits, dim=-1)
transcription = processor.batch_decode(predicted_ids)[0]
```

#### 2. 音素级评分技术

**高级音频分析**：
```python
from .音素评分模块 import PhonemeScorer, DetailedPronunciationResult
from .音素特征提取 import AcousticFeatureExtractor, PhonemeAligner, PronunciationQualityAssessor
```

**特征提取技术**：
- **基频分析**：F0轨迹提取
- **共振峰分析**：语音质量评估
- **时域特征**：音素时长分析
- **频谱特征**：频谱质量评估

#### 3. 语音转写技术

**Whisper模型集成**：
```python
import whisper

def transcribe_audio(audio_path):
    model = whisper.load_model("small")
    result = model.transcribe(audio_path)
    return result["text"]
```

### 📝 语法检测技术

#### 1. LanguageTool集成 (`src/core/语法检查.py`)

**LanguageTool库使用**：
```python
from language_tool_python import LanguageTool

# API连接
tool = LanguageTool('en-US', remote_server='https://api.languagetool.org')
matches = tool.check(text)
corrected_text = tool.correct(text)
```

**错误信息处理**：
- **规则ID映射**：错误类型中英文对照
- **上下文提取**：错误位置和建议
- **批量处理**：多个错误统一处理

### 🔊 音频处理技术栈

#### 1. 音频格式转换

**FFmpeg集成**：
```python
import subprocess

def convert_to_wav_16k(input_path):
    cmd = [
        'ffmpeg', '-y', '-i', input_path,
        '-ac', '1', '-ar', '16000',
        '-f', 'wav',
        output_path
    ]
    result = subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
```

#### 2. 音频录制技术

**SoundDevice录音**：
```python
import sounddevice as sd

def record_audio(duration=3, sr=16000):
    audio = sd.rec(int(duration * sr), samplerate=sr, channels=1)
    sd.wait()
    return audio.flatten()
```

#### 3. 音频分析技术

**LibROSA音频处理**：
```python
import librosa

# 音频加载
audio_data, sr = librosa.load(audio_path, sr=16000)

# 音频重采样
if sr != 16000:
    audio_data = librosa.resample(audio_data, orig_sr=sr, target_sr=16000)
```

### 🗄️ 数据存储技术

#### 1. 文件系统管理

**目录结构管理**：
```python
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
AUDIO_UPLOAD_DIR = os.path.join(BASE_DIR, 'data', 'audio', 'uploads')
os.makedirs(AUDIO_UPLOAD_DIR, exist_ok=True)
```

**文件操作**：
- **临时文件管理**：UUID生成唯一文件名
- **文件类型检测**：扩展名和MIME类型验证
- **文件清理**：自动清理临时文件

#### 2. 数据序列化

**JSON数据处理**：
```python
# API响应
return jsonify({
    "score": f"{score:.1f}",
    "detailed_result": result_data
})

# 配置文件解析
import yaml
with open('config/config.yaml', 'r') as f:
    config = yaml.safe_load(f)
```

### 🔐 安全技术实现

#### 1. 用户认证

**JWT令牌技术**：
```python
from src.core.db_user_manager import get_db_user_manager

# 令牌验证
token = request.headers.get('Authorization') or request.cookies.get('auth_token')
if token and token.startswith('Bearer '):
    token = token[7:]

user_manager = get_db_user_manager()
user = user_manager.verify_user(token)
```

#### 2. 输入验证

**参数验证**：
```python
# 表单数据验证
reference_text = request.form.get('reference_text')
audio_file = request.files.get('audio_file')

if not reference_text:
    return jsonify({'error': '缺少参考文本'}), 400
if not audio_file:
    return jsonify({'error': '缺少音频文件'}), 400
```

### 📊 数据可视化技术

#### 1. ECharts图表集成

**波形图显示**：
```javascript
const option = {
    series: [{
        name: '音频波形',
        type: 'line',
        data: waveformData,
        areaStyle: {
            color: {
                type: 'linear',
                colorStops: [
                    {offset: 0, color: 'rgba(58, 134, 255, 0.3)'},
                    {offset: 1, color: 'rgba(58, 134, 255, 0.05)'}
                ]
            }
        }
    }]
};
```

**评分仪表盘**：
```javascript
const gaugeOption = {
    series: [{
        name: '发音评分',
        type: 'gauge',
        min: 0,
        max: 100,
        data: [{value: score, name: '得分'}]
    }]
};
```

### 🔄 异步处理技术

#### 1. 前端异步操作

**Promise和async/await**：
```javascript
async function submitScore() {
    try {
        const response = await axios.post('/api/score-pronunciation', formData);
        const result = response.data;
        updateScoreDisplay(result.score);
    } catch (error) {
        console.error('评分失败:', error);
    }
}
```

#### 2. 后端异步处理

**延迟导入优化**：
```python
def _import_dependencies():
    """延迟导入依赖库，减少Flask重载触发"""
    try:
        import torch
        from transformers import Wav2Vec2Processor, Wav2Vec2ForCTC
        import librosa
        return torch, Wav2Vec2Processor, Wav2Vec2ForCTC, librosa
    except ImportError as e:
        return None, None, None, None
```

### 🎯 错误处理技术

#### 1. 异常捕获和处理

**分层错误处理**：
```python
try:
    # 核心业务逻辑
    result = process_audio(audio_data)
except ImportError as e:
    return jsonify({"error": f"依赖库缺失: {str(e)}"}), 500
except ValueError as e:
    return jsonify({"error": f"数据验证失败: {str(e)}"}), 400
except Exception as e:
    traceback.print_exc()
    return jsonify({"error": f"系统错误: {str(e)}"}), 500
finally:
    # 资源清理
    cleanup_temp_files()
```

#### 2. 前端错误处理

**用户友好的错误提示**：
```javascript
.catch(error => {
    let errorMessage = '操作失败，请重试';
    if (error.response && error.response.data && error.response.data.error) {
        errorMessage = error.response.data.error;
    }
    alert(errorMessage);
});
```

### 📦 依赖管理技术

#### 1. Requirements.txt依赖声明

**核心依赖分类**：
```txt
# Web框架
Flask==3.0.3
Werkzeug==3.0.1

# 深度学习
torch==2.2.2
transformers==4.41.2

# 音频处理
librosa==0.10.2.post1
soundfile==0.12.1

# 数据库
SQLAlchemy==2.0.25
PyMySQL==1.1.0

# 语法检测
language_tool_python==2.7.1
```

#### 2. 配置管理技术

**YAML配置文件**：
```yaml
# config/config.yaml
database:
  type: "mysql"
  host: "localhost"
  port: 3306

model:
  whisper: "small"
  wav2vec2: "facebook/wav2vec2-base-960h"

phoneme_scoring:
  enabled: true
  alignment_method: "ctc"
```

### 🔧 开发工具技术

#### 1. 调试和日志

**Python日志系统**：
```python
print(f"🎯 音频上传目录: {AUDIO_UPLOAD_DIR}")
print(f"音频数据长度: {len(audio_data)} 采样点")
print(f"语音识别结果: {transcription}")
```

#### 2. 性能监控

**执行时间追踪**：
```python
import time
start_time = time.time()
# 处理逻辑
end_time = time.time()
print(f"处理耗时: {end_time - start_time:.2f}秒")
```

---

## 📈 技术选型说明

### 🎯 选型原则

1. **成熟稳定**：选择经过验证的主流技术
2. **性能优先**：考虑处理大型AI模型的性能需求
3. **扩展性**：支持功能模块的独立扩展
4. **易维护**：代码结构清晰，便于后期维护

### 🔄 技术演进路径

1. **初期**：基础Flask + 简单评分算法
2. **发展期**：集成AI模型 + 数据库支持
3. **成熟期**：音素级分析 + 用户系统
4. **优化期**：性能调优 + 安全加固

这个技术清单详细展示了项目中每个组件具体使用的技术栈，从前端的HTML/CSS/JavaScript到后端的Flask/PyTorch，再到AI模型的集成和数据处理，涵盖了整个技术架构的各个层面。